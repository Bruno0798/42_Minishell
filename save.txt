	t_shell *shell;
	t_env *envp = NULL;
	
    //pid_t	pid;
    (void) argv;
    (void) argc;
	char **parmList = (char **)malloc(sizeof(char *) * 4);

	shell = (t_shell *)malloc(sizeof(t_shell));
	shell->var = (t_variables *)malloc(sizeof(t_variables));
	
	get_env(&envp, env);
	shell->var->home = ft_search_key(envp, "HOME");
	shell->var->path = ft_search_key(envp, "PATH");
	parmList[0] = "/bi";
	parmList[1] = "-p";
	parmList[2] = shell->var->home;
	parmList[3] = NULL;

	shell->var->paths = ft_split(shell->var->path, ':');

	while (1)
	{
		shell->line = readline("Minishell$>");
		parser(shell);
	}
	
/*     if ((pid = fork()) == -1)
        perror("fork error");
    else if (pid == 0)
    {
        execve("ls", parmList, env);
        exit(EXIT_FAILURE);     // Exit the child process on failure
    }
    else
	{
        waitpid(pid, NULL, 0); // Wait for the child process to finish
	} */
